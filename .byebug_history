c
customers_to_invite.first.to_s
customers_to_invite.first
customers_to_invite
ustomers_to_invite
c
customers_to_invite.first.to_s
customers_to_invite.first
customers_to_invite.size
customers_to_invite
c
customers.within_distance of: distance.first
customers.within_distance of: distance
n
s
c
customers.within_distance of: distance
n
s
c
e
n
s
c
e
n
input
n
s
Slainte::Inviter.run(path: path)
c
s
path
s
Slainte::Inviter.run(path: path)
c
Slainte::Inviter.run(path: path)
exit
xit
Slantie::Inviter.run(path: path)
c
Dummy.distance_in_km(office_location, destination)
c
Dummy.new.distance_in_km(office_location, destination)
Dummy.distance_in_km(office_location, destination)
c
Slainte::GeoCalculator.instance_method(:distance_in_km)
Slainte::GeoCalculator.distance_in_km
Slainte::GeoCalculator
Slainte::GeoCalculator.distance_in_km(office_location, destination)
c
matches.size
matches = customers.within_distance of: 100
c
records
c
of
resulting_distance
c
customers.within_distance of: 100
c
customers.within
c
records.pop
records.first
records.last
records.class
records
records[32]
records[21]
records.last
records.first.user_id
records.first
c
records
records.sort_by { |r| r.user_id } == records
records.sort_by { |r| r.user_id }
records
c
Slainte::Customers.new records_hash
exit
Slainte::Customers.new records_hash
exit
eit
e
n
s
n
data
n
s
exit
s
c
e
s
exit
c
exit
c
new_customer == a
a = new_customer.clone
new_customer
b
b = new_customer.clone
new_customer
c
exit
c
@hash
s
c
@hash
s
exit
c
o
@hash
s
c
@hash[o]
o
@hash
s
sorted_records.include? new_customer
c
input
c
exit
s
n
input
exit
records
recoreds
sorted_records
s
n
exit
eixt
c
{ user_id: user_id, name: name, latitude: latitude, longitude: longitude }.class
{ user_id: user_id, name: name, latitude: latitude, longitude: longitude }
exit
c
self.instance_variables.each {|var| hash[var.to_s.delete("@")] = gift.instance_variable_get(var) }
c
instance_variables.each {|var| hash[var.to_s.delete("@")] = gift.instance_variable_get(var) }
self.as_json
self.instance_values
self.attributes
self
self.instance_values
self.to_hash
self.to_h
exit
c
self.hash
self
c
exit
pp sorted_records
require "pp"
c
exit
pp sorted_records
require "pp"
pp sorted_records
sorted_records
exit
c
other
c
pp a
require "pp"
pp a
a[0]
a.second
a.first
a = sorted_records
sorted_records[0]
sorted_records.second
sorted_records.first
sorted_records.size
sorted_records
sordet_records
n
c
sorted_records.first
sorted_records
n
s
exit
record.user_id
record
c
exit
c
customer
n
s
c
e
n
s
exit
c
Customer.new name: "aaa"
Customer
Customer.new(user_id: record.user_id, name: record.name, latitude: record.latitude, longitude: record.longitude)
record
n
s
exit
c
n
s
c
a.class
a
a = records.map { |record| JSON.parse(record, symbolize_names: true) }
SortedSet.new records.map { |record| JSON.parse(record, symbolize_names: true) }
c
exit
c
a.sort
a.first
a.size
a.first
a.class
a = Set.new records.map { |record| JSON.parse(record, symbolize_names: true) }
a = records.map { |record| JSON.parse(record, symbolize_names: true) }
Set.new records.map { |record| JSON.parse(record, symbolize_names: true) }
c
records.map { |record| JSON.parse(record, symbolize_names: true, object_class: Set) }
records.map { |record| JSON.parse(record, symbolize_names: true, object_class: OpenStruct) }
records.map { |record| JSON.parse(record, symbolize_names: true, object_class: Set) }
records.map { |record| JSON.parse(record, symbolize_names: true) }
c
JSON.parse(records, symbolize_names: true)
c
s.customers
c
s.customers
c
a
a.sort
a.sorted?
a.second
a.first
a
a = SortedSet.new(s.customers)
SortedSet.new(s.customers)
Set.new(s.customers).first
Set.new(s.customers)
s.customers
